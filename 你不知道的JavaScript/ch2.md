# 第二章 this的全面解析

## 2.1 调用位置

在理解this的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）

 

## 2.2绑定规则

你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条，我们首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。

### 2.2.1默认绑定

首先要介绍的是最常见的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。

 如果使用严格模式，那么全局对象将无法使用默认规则，因此this会绑定到undefined。

```javascript
function foo(){
"usestrict"
	console.log("this.a") 
}
var a=2;
foo();//TypeError:this is underfine
```

这里有一个微妙但非常重要的细节，虽然this的绑定规则完全取决于调用位置，但是只有foo()运行在非strict环境下，默认绑定才能绑定到全局对象；严格模式下与foo()的调用位置无关。

```javascript
function foo() { 
console.log(this.a);
}
var a=2;
(function () {
"use strict";
foo();//2
})();
```

 

### 2.2.2隐式绑定

> 另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。
>
> 当函数引用有上下文对象时，隐式绑定规则则会把函数调用中的this绑定到这个上下文对象。

 

对象属性引用链中只有最顶层或者说最后一层会影响调用位置。例如：

```javascript
function foo() {
	console.log(this.a);
}
var obj2={
a:42,
foo:foo
};
var obj1={
a:2,
obj2:obj2
}
obj1.obj2.foo();//42
```



### 2.2.3 显式绑定

call(….)和apply(…)方法，它们的第一个参数是一个对象，它们会把这个对象绑定到this，接着调用函数时指定这个this。因为你可以直接指定this的绑定对象，因此我们称之为显式绑定。

 

### 2.2.4new绑定

使用new来调用foo()时，我们会构造一个新对象并把它绑定到foo()调用中的this上。new是最后一种可以影响函数调用时this的绑定行为的方法，我们称之为new绑定

 

判断this

现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则，可以按照下面的顺序来进行判断：

1.函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。

var bar= new foo()

2.函数是否通过call、apply（显示绑定）或者硬绑定调用，如果是的话，this绑定的是指定的对象。

var bar= foo.call(obj2)

3.函数是否在某个上下文对象中调用（隐式绑定)?如果是的话，this绑定的是那个上下文对象。

var bar= obj1.foo()

4.如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。

var bar=  foo()

 

 **ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this。**



 

 