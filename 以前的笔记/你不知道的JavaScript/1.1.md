# 第一章 作用域是什么

## 1.1编译原理

- 分词/词法分析

这个过程会将由字符串分解成有意义的代码块,这些代码块被称为词法单元。

- 解析/语法分析

这个过程是将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为‘’抽象语法树‘’（AST）。

- 代码生成

将AST转换成可执行代码的过程称为代码生成。

例如var a=2；将AST转换为一组机器指令，用来创建一个叫作a的变量（包括分配内存等），并将一个值储存在a中。

## 1.2理解作用域

### 1.2.1演员表

- 引擎

从头到尾负责整个JavaScript程序的编译及执行过程。

- 编译器

引擎的好朋友之一，负责语法分析及代码生成等

- 作用域

引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

举例说明

```javascript
var a=2;
```

 编译器处理如下：

1. 遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略说明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a；
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a=2这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找变量。

总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

### 1.2.3编译器有话说

> LHS和RHS的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头在（RHS）”

## 1.3 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

考虑以下代码

```javascript
function foo(a){
  console.log(a+b);
}
var b=2;
foo(2);//4
```

对b进行RHS引用无法再函数foo内部完成，但可以再上一级作用域完成

> 遍历嵌套作用域的规则很简单：引擎从当前的执行作用域开始查找变量。如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

## 1.4 异常

不成功的RHS引出会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常（严格模式下）

TypeError代表作用域判别成功，但是对结果的操作是非法或不合理的。

