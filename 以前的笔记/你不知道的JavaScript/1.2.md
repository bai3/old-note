# 第二章 词法作用域

## 2.1 词法阶段

> 词法作用域就是定义在词法阶段的作用域

> 无论函数在哪里被调用,也无论它如何被调用,它的词法作用域都只能由函数被声明时所处的位置决定的

## 2.2 欺骗词法

### 2.2.1 eval

JavaScript中的eval函数可以接受一个字符串为参数,并将其中的内容视为好像在书写时就存在于程序中这个位置的代码.(不推荐使用)

### 2.2.2 with

with通常被当作重复引用同一个对象中的多个属性快捷方式,可以不重复引用对象本身.

```javascript
var obj = {
	a: 1,
	b: 2,
	c: 3
};
//单调乏味的重复obj
obj.a=2;
obj.b=3;
obj.c=4;
//快捷方式如下
with (obj){
a=2;
b=3;
c=4;
}
```

**with可以将一个没有或者有多个属性的对象处理为一个完全隔离的词法作用域,因此这个对象属性也会被处理定义在这个作用域的词法作用域.**

**尽管with块可以将一个对象处理为词法作用域,但是这个块内部正常的var声明并不会被限制在这个块的作用域中,而是被添加到with所处的函数作用域中.**

**eval(…)函数如果接受了含有一个或多个声明的代码,就会修改其所处的词法作用域,而with声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域**

举个下面例子进行说明

```javascript
function foo(obj){
	with(obj){
	a = 2;
}
}
var o2={
	b:3
};
foo(o2);
console.log(o2.a)//undefined
console.log(a);//2
```

因为o2的作用域,foo(…)作用域和全局作用域中都没有找到标识符a,因此当执行a=2时,自动会创建一个全局变量,所以最后一行代码才会显示a

注意:这两个机制的副作用是引擎无法在编译时对作用域查找进行优化,因为引擎只能谨慎地认为这样的优化是无效的.使用其中任何一个机制都会导致代码运行变慢,所以还是不要使用.

